<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

<title>Cool C Programming</title>

<meta name="description" content="Music, Food and Code - The three dimensions to my world.">



<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Alegreya:400,700">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Alegreya+Sans:400,700">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inconsolata:400,700">
<link rel="stylesheet" type="text/css" href="/css/main.css">
<link rel="stylesheet" type="text/css" href="/css/footable.bootstrap.min.css">
<script type="text/javascript" src="/js/jquery-3.1.1.min.js"></script>
<script type="text/javascript" src="/js/util.js"></script>
<script type="text/javascript" src="/js/popper.js"></script>
<script type="text/javascript" src="/js/tooltip.js"></script>
<script type="text/javascript" src="/js/bootstrap/bootstrap.bundle.min.js"></script>
<script type="text/javascript" src="/js/moment.min.js"></script>
<script type="text/javascript" src="/js/footable.min.js"></script>
<link rel="shortcut icon" type="image/png" href=/favicon_pride.png>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script defer src="https://pro.fontawesome.com/releases/v5.0.10/js/all.js" integrity="sha384-+1nLPoB0gaUktsZJP+ycZectl3GX7wP8Xf2PE/JHrb7X1u7Emm+v7wJMbAcPr8Ge" crossorigin="anonymous"></script>



<body>
  <div class="header wrapper">
    </br>
<div class="container">
  <div class="row">
    
      <div class="col menuItem">
        <a class="text-dark" href="/" target=""><i class="fas fa-home"></i></a>
      </div>
    
      <div class="col menuItem">
        <a class="text-dark" href="/blog/" target=""><i class="fas fa-book"></i></a>
      </div>
    
      <div class="col menuItem">
        <a class="text-dark" href="/music/" target=""><i class="fab fa-itunes-note"></i></a>
      </div>
    
  </div>
</div>
</br>

  </div>
  </br>
  <div class="wrapper">
    <div class="post">
  <div class="post__title">
    <h1>Cool C Programming</h1>
  </div>
  <div class="post__date">
    <p>September 9, 2013</p>
  </div>
  <div class="post__meta">
    <p></p>
  </div>
  <div class="post__content"?>
    <p>This post contains the writeup of my talk on <strong>Cool C Programming</strong> as part of the <strong>Tech Talk Tuesday</strong> series by <strong><a href="http://pesos.pes.edu">PES OpenSource</a></strong> at PES Institute of Technology.
(Please ignore any typos in this post; its pretty long and I wrote it in a hurry!)</p>

<h2 id="the-c-preprocessor">The C Preprocessor</h2>

<p>In the C Program build process, there are three main phases.</p>

<ul>
  <li>Preprocessing</li>
  <li>Compiling</li>
  <li>Linking</li>
</ul>

<p>The C Preprocessor is dumb! It does not know anything about a C program. It is mainly used to manage the program’s text according to our needs before the compiler begins its task. Managing involves including of header files, conditional inclusion of pieces of code, expanding macros, etc.<br />
<!-- more -->
If you want to see the output of the preprocessor, you can use the <code class="highlighter-rouge">-E</code> flag for the compiler; ie compile the program as <code class="highlighter-rouge">gcc -E file.c</code>. This dumps the preprocessed output of file.c onto your terminal.</p>

<p>There are three standard input/output buffers</p>

<ul>
  <li><code class="highlighter-rouge">stdin</code> The input buffer</li>
  <li><code class="highlighter-rouge">stdout</code> The default output buffer</li>
  <li><code class="highlighter-rouge">stderr</code> The output buffer for error/log messages</li>
</ul>

<h3 id="conditional-syntax---ifdef-and-ifndef">Conditional Syntax - <code class="highlighter-rouge">#ifdef</code> and <code class="highlighter-rouge">#ifndef</code></h3>

<p>The preprocessor directive <code class="highlighter-rouge">#ifdef</code> is used to define conditional groups of code at the preprocessor level. Based on a condition, a piece of code may or may not be included in the program. The body of this directive is usually termed <em>controlled text</em></p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#ifdef SOME_MACRO
</span><span class="c1">//some piece of code
</span><span class="cp">#endif
</span></code></pre>
</div>

<p>In the above example, the body of <code class="highlighter-rouge">#ifdef</code> is included only if <code class="highlighter-rouge">SOME_MACRO</code> is defined. The <code class="highlighter-rouge">#define</code> directive is used to define MACROs.</p>

<h4 id="example">Example</h4>

<p>Here’s a sample program.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#ifdef SOME_MACRO
</span><span class="kt">void</span> <span class="nf">foo</span> <span class="p">()</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<h6 id="fig11">Fig(1.1)</h6>

<p>Observe that <code class="highlighter-rouge">SOME_MACRO</code> is not defined. And hence the controlled text should not be included. And here’s the output of the preprocessor (compiled with <code class="highlighter-rouge">-E</code> option)</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp"># 1 "1.c"
# 1 "&lt;command-line&gt;"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "&lt;command-line&gt;" 2
# 1 "1.c"
</span>





<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<h6 id="fig12">Fig(1.2)</h6>

<p>Let me now define the MACRO <code class="highlighter-rouge">#ifdef</code> using <code class="highlighter-rouge">#define</code>.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#define SOME_MACRO
</span>
<span class="cp">#ifdef SOME_MACRO
</span><span class="kt">void</span> <span class="nf">foo</span> <span class="p">()</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
</div>
<h6 id="fig13">Fig(1.3)</h6>

<p>And this is the output of the preprocessor now.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp"># 1 "1.c"
# 1 "&lt;command-line&gt;"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "&lt;command-line&gt;" 2
# 1 "1.c"
</span>


<span class="kt">void</span> <span class="nf">foo</span> <span class="p">()</span>
<span class="p">{</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
</div>
<h6 id="fig14">Fig(1.4)</h6>

<p>You can observe that when the macro is defined, the controlled text is included. Note again, that the preprocessor does not know that the controlled text is a function or any of the C constructs. All it sees is some text.<br />
You can also define MACROs when invoking the compiler with the <code class="highlighter-rouge">-D</code> option. Compiling the code in Fig(1.1) as <code class="highlighter-rouge">gcc -E -DSOME_MACRO 1.c</code> gives me the same output as Fig(1.4).</p>

<p>MACROs also can be object-like MACROs and function-like MACROs.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#define BAR 5
#define FOO(X) printf("%d", X)
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">//FOO is a function-like MACRO and BAR is an object-like MACRO.
</span>    <span class="n">FOO</span><span class="p">(</span><span class="n">BAR</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<h6 id="fig15">Fig(1.5)</h6>

<p>Here’s the preprocessed output of the code in Fig(1.5)</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp"># 1 "1.c"
# 1 "&lt;command-line&gt;"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "&lt;command-line&gt;" 2
# 1 "1.c"
</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
</div>
<h6 id="fig16">Fig(1.6)</h6>

<p><code class="highlighter-rouge">BAR</code> is an object-like MACRO which the preprocessor substitutes as 5, according to its definition. Therefore, the MACRO call <code class="highlighter-rouge">FOO(BAR)</code> is now <code class="highlighter-rouge">FOO(5)</code>. It then expands the function-like MACRO <code class="highlighter-rouge">FOO</code> with its parameter as 5. You therefore see <code class="highlighter-rouge">printf("%d", 5);</code>. Note that the <code class="highlighter-rouge">printf</code> of <code class="highlighter-rouge">FOO</code> does not end with a semicolon. But the MACRO is used with a semicolon <code class="highlighter-rouge">FOO(...);</code>. This ensures that printf ends with a semicolon. Why this approach? Its a standard convention to end every statement of a C program with a semicolon and it would be very odd to have some line not ending with it.</p>

<h3 id="and-now-for-a-few-tricks">And now for a few tricks</h3>

<h4 id="creating-debug-macros">Creating debug MACROs</h4>

<p>Lot of programmers are used to debug by logging the program’s execution. This can be as simple as using <code class="highlighter-rouge">printf</code> all over the code to print messages (on the <code class="highlighter-rouge">stderr</code> buffer) and use this information to debug. Further more, you may want to write pieces of code to mainly check the correctness of the program (only while you’re developing it). When its time for you to release your code, you’ll have to remove all the logging statements, blocks of code which was used to check correctness, etc. This brings in a lot of work the developer. Additionally, if at some later point of time, the user had to improve his code, he might want to insert all such blocks again (its literally a headache!).<br />
Now, the preprocessor turns out to be very helpful!</p>

<p>The following program demonstrates three features widely used in C Programs. We’ll go through each one by one</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
</span>
<span class="cp">#ifdef CHECK_ENABLED
#define CHECK(X, Y) \
do { printf("Performing Assertion\n"); assert((X - Y) != 0); printf("Assertion passed\n"); } while (0)
#else
#define CHECK(X, Y)
#endif
</span>
<span class="kt">void</span> <span class="nf">foo</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">CHECK</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">"%d: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span>
<span class="p">{</span>
    <span class="n">foo</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">foo</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
</div>
<h6 id="fig17">Fig(1.7)</h6>

<p>Let this be a file, <em>debug.c</em> .
What is this program trying to do? This program calls the function <code class="highlighter-rouge">foo()</code> with 2 arguments, <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code>.; and foo wants perform the operation <code class="highlighter-rouge">(x + y) / (x - y)</code>. It also uses a function-like MACRO <code class="highlighter-rouge">CHECK</code> which expands to an assert statement (forget about the <code class="highlighter-rouge">do {...} while(0)</code> for now). <code class="highlighter-rouge">assert</code> is a library function declared in <code class="highlighter-rouge">assert.h</code> which aborts the program if the given assertion fails (in this example <code class="highlighter-rouge">(x - y) != 0</code>).</p>

<p>According to our expectations, The program and must execute the first <code class="highlighter-rouge">foo(4, 3)</code> function call and should fail when trying execute the second <code class="highlighter-rouge">foo(4, 4)</code> function call because of division by zero (Forget about the <code class="highlighter-rouge">__LINE__</code> in the printf). Now let me compile it without defining the <code class="highlighter-rouge">CHECK_ENABLED</code> MACRO. Compile with <code class="highlighter-rouge">gcc debug.c</code> and run <code class="highlighter-rouge">./a.out</code>; the following is the output.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>14: 7
Floating point exception (core dumped)

</code></pre>
</div>
<h6 id="fig18">Fig(1.8)</h6>

<p>It worked as expected. The program printed “7” and failed when executing the second <code class="highlighter-rouge">foo(4, 4)</code> function call because of the division with zero. Let me now compile with also defining the <code class="highlighter-rouge">CHECK_ENABLED</code> MACRO. Compile with <code class="highlighter-rouge">gcc debug.c DCHECK_ENABLED</code> and run <code class="highlighter-rouge">./a.out</code> and here’s the output.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Performing Assertion
Assertion passed
14: 7
Performing Assertion
a.out: 1_preprocessor.c:13: foo: Assertion `(x - y) != 0' failed.
Aborted (core dumped)

</code></pre>
</div>
<h6 id="fig19">Fig(1.9)</h6>

<p>Wow! That’s magic! The program did not even try to perform the division because the assertion <code class="highlighter-rouge">(4 - 4) != 0</code> failed and also printed a lot of debugging messages!</p>

<p>Let us now analyze what happened.<br />
In Fig(1.9), the program was compiled with the <code class="highlighter-rouge">CHECK_ENABLED</code> MACRO defined which included the following controlled text in the program.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#define CHECK(X, Y) \
do { printf("Performing Assertion\n"); assert((X - Y) != 0); printf("Assertion passed\n"); } while (0)
</span></code></pre>
</div>
<h6 id="fig110">Fig(1.10)</h6>

<p>This defines a function-like MACRO <code class="highlighter-rouge">CHECK(X, Y)</code> to be <code class="highlighter-rouge">do { printf("Performing Assertion\n"); assert((X - Y) != 0); printf("Assertion passed\n"); } while (0)</code>. Hence this function-like MACRO <code class="highlighter-rouge">CHECK(X, Y);</code> expands to <code class="highlighter-rouge">do { printf("Performing Assertion\n"); assert((X - Y) != 0); printf("Assertion passed\n"); } while (0)</code>. With <code class="highlighter-rouge">foo(4, 3);</code> this assertion succeeds and prints “7”; with <code class="highlighter-rouge">foo(4, 4");</code> this assertion fails and the program aborts.</p>

<p>When the program is compiled without defining <code class="highlighter-rouge">CHECK_ENABLED</code> MACRO [refer Fig(1.8)], the controlled text in the else portion of the conditional group gets included in the program. ie</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#define CHECK(X, Y)
</span></code></pre>
</div>
<h6 id="fig111">Fig(1.11)</h6>

<p>This defines a function-like MACRO <code class="highlighter-rouge">CHECK(X, Y)</code> to nothing! So the function-like MACRO expands to nothing! ie the assertion is not in the code any more and so the program prints “7” and gets a floating point exception when trying a division with zero.</p>

<p>So what just happened? In Fig(1.9) the program was executed in a debugging mode; the debugging mode in the above example was enabled by defining the <code class="highlighter-rouge">CHECK_ENABLED</code> MACRO; and in this debugging mode, the assertion statement was included in the code and the program aborted stating where it failed and why. The debugging mode also included some debugging messages which I printed so that I’d know what went wrong and where.<br />
When the debugging mode wasn’t enabled (by not defining the <code class="highlighter-rouge">CHECK_ENABLED</code> MACRO), the assertion wasn’t included in the code by the preprocessor as <code class="highlighter-rouge">CHECK(X, Y)</code> expands to nothing. Now the program crashes.<br />
Look at the error that comes up - <code class="highlighter-rouge">Floating point exception (core dumped)</code>. You cannot make out what happened where! The runtime threw an error message and exited the program. Whereas when the debugging is enabled, the assertion gives a better error message - <code class="highlighter-rouge">a.out: 1_preprocessor.c:13: foo: Assertion </code>(x - y) != 0’ failed.<code class="highlighter-rouge">. It failed in line 13. That's where the function-like MACRO </code>CHECK(x, y)` expands.</p>

<p><strong>Feature/Trick #1</strong> : In short, you can now run your program in debug mode and release mode by just defining / not-defining a debug MACRO. Normally this debug MACRO is <code class="highlighter-rouge">DEBUG</code>. I’ve used <code class="highlighter-rouge">CHECK_ENABLED</code> in the example to include some checks. You must also understand now that in the release mode, we only concentrate on execution of the program and not error checking because they can make the program slower. Imagine calling the <code class="highlighter-rouge">foo(4, 3)</code> a million times in the debug mode. The assert function is called a million times but your intention is to check the correctness of the code and not the execution speed. In the release mode, the assertion is not even there and so your program executes much faster and is assumed to be correct.<br />
Nice trick huh? Such an amazing work around to solve such an important problem and that too with just using the C Preprocessor!</p>

<p>I mentioned long back that there are three features the above program [Fig(1.7)] tries to show. The first was the debug/release switch which we have covered in detail. The second is this very odd statement -</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">do</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">"Performing Assertion</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="n">assert</span><span class="p">((</span><span class="n">X</span> <span class="o">-</span> <span class="n">Y</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">"Assertion passed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>

</code></pre>
</div>
<h6 id="fig112">Fig(1.12)</h6>

<p><strong>Feature/Trick #2</strong> : Why the <code class="highlighter-rouge">do { ... } while(0)</code> ??! Why can’t I just write a set of statements? Maybe because I wanted to group them. Then why couldn’t I just use <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">...</span><span class="w"> </span><span class="p">}</span></code> instead of the do while zero?<br />
Consider this situation</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#define FOO(X, Y) printf("%s\n", X); printf("%s\n", Y)
</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="cm">/*some condition*/</span><span class="p">)</span>
        <span class="n">FOO</span><span class="p">(</span><span class="s">"YES"</span><span class="p">,</span> <span class="s">"TRUE"</span><span class="p">);</span>
<span class="p">}</span>

</code></pre>
</div>
<h6 id="fig113">Fig(1.13)</h6>

<p>Remember that its a standard convention not to end the code within a function-like MACRO with a semicolon (because the MACRO is used with a semicolon at the end)? So the second <code class="highlighter-rouge">printf</code> doesn’t end with a semicolon, its taken care of later.<br />
An if condition is associated only with the statement/block following it. After the function-like MACRO <code class="highlighter-rouge">FOO(X, Y)</code> expands, we have something like the following -</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="cm">/*some condition*/</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="s">"YES"</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="s">"TRUE"</span><span class="p">);</span>
</code></pre>
</div>
<h6 id="fig114">Fig(1.14)</h6>

<p>Note that the first printf gets associated with the if condition and not the second! So “TRUE” is always printed. What a bug! So to avoid this let me rewrite the program as follows -</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#define FOO(X, Y) { printf("%s\n", X); printf("%s\n", Y) }
</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="cm">/*some condition*/</span><span class="p">)</span>
        <span class="n">FOO</span><span class="p">(</span><span class="s">"YES"</span><span class="p">,</span> <span class="s">"TRUE"</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">FOO</span><span class="p">(</span><span class="s">"NO"</span><span class="p">,</span> <span class="s">"FALSE"</span><span class="p">);</span>
<span class="p">}</span>

</code></pre>
</div>
<h6 id="fig115">Fig(1.15)</h6>

<p>Notice that I’ve now included flower brackets to group the two printfs into a block and I also wanted an else portion which I’ve included. This sounds fine. Lets now observe what happens when the function-like MACRO <code class="highlighter-rouge">FOO(X, Y)</code> expands.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="cm">/*some condition*/</span><span class="p">)</span>
    <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="s">"YES"</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="s">"TRUE"</span><span class="p">)</span> <span class="p">};</span>
<span class="k">else</span>
    <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="s">"NO"</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="s">"FALSE"</span><span class="p">)</span> <span class="p">};</span>
</code></pre>
</div>
<h6 id="fig116">Fig(1.16)</h6>

<p>Observe that the second printf doesn’t end with a semicolon but the blocks end with a semicolon, because the semicolon was present after the MACRO. This will through a bunch of errors because printf doesn’t have a semicolon to start with and there’s a semicolon after the if block (which ends the if block) so the else portion becomes stray code without a corresponding if! Uff! This is crazy! Well, no. Here is why do while zero is used. Lets rewrite the program using do while zero</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#define FOO(X, Y) do { printf("%s\n", X); printf("%s\n", Y); } while(0)
</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="cm">/*some condition*/</span><span class="p">)</span>
        <span class="n">FOO</span><span class="p">(</span><span class="s">"YES"</span><span class="p">,</span> <span class="s">"TRUE"</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">FOO</span><span class="p">(</span><span class="s">"NO"</span><span class="p">,</span> <span class="s">"FALSE"</span><span class="p">);</span>
<span class="p">}</span>

</code></pre>
</div>
<h6 id="fig117">Fig(1.17)</h6>

<p>When the MACRO expands, we get it like this -</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="cm">/*some condition*/</span><span class="p">)</span>
    <span class="k">do</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="s">"YES"</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="s">"TRUE"</span><span class="p">);</span> <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">else</span>
    <span class="k">do</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="s">"NO"</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="s">"FALSE"</span><span class="p">);</span> <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</code></pre>
</div>
<h6 id="fig118">Fig(1.18)</h6>

<p>You can now see that the if block contains one statement which is a loop. All the statements are placed in that loop and this loop executes only once because the condition fails. Isn’t that amazing?!</p>

<p><strong>Feature/Trick #3</strong> : And lastly, the third feature the program uses is <code class="highlighter-rouge">printf("%d", __LINE__);</code>. <code class="highlighter-rouge">__LINE__</code> is a preprocessor MACRO that expands to current line number in the source file, as an integer. <code class="highlighter-rouge">__LINE__</code> is useful when generating log statements, debug messages, etc. There’s also <code class="highlighter-rouge">__FILE__</code> which expands to the current file name.</p>

<p><strong>Feature/Trick #4</strong> : Consider the following header file (say <em>file.h</em>)</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

</code></pre>
</div>
<h6 id="fig119">Fig(1.19)</h6>

<p>Now if your project contains a lot of files and you include this header file in many of them and compile, you’ll encounter errors of redeclaration! And so header files begin with the following construct</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#ifndef FILE_H
#define FILE_H
</span>
<span class="k">struct</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif
</span></code></pre>
</div>
<h6 id="fig120">Fig(1.20)</h6>

<p>So what’s the change now? When some .c file which includes this header is being compiled, it sees the directive <code class="highlighter-rouge">#ifndef FILE_H ... #endif</code>; which basically means include the controlled text if the MACRO <code class="highlighter-rouge">FILE_H</code> is not defined. But wait, what is this present in the controlled text? <code class="highlighter-rouge">#define FILE_H</code>. What I’m doing is defining the MACRO <code class="highlighter-rouge">FILE_H</code> and including the header contents if <code class="highlighter-rouge">FILE_H</code> was previously not declared. Now when another file is being compiled which includes the same header, the compiler sees that the MACRO <code class="highlighter-rouge">FILE_H</code>  is defined now and skips including the controlled text of the conditional group avoiding redeclaration of structures and other entities of a header file.</p>

<p><strong>Feature/Trick 5</strong> : This is the last preprocessor feature I’ll be discussing! The C preprocessor gives two directives <code class="highlighter-rouge">#warning</code> and <code class="highlighter-rouge">#error</code>. I expect you might have guessed their uses. Consider the following code snippet -</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#ifdef USE_OLD_FOO
#warning "Using old foo(). This is deprecated! You are getting this message because USE_OLD_FOO is defined"
</span><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">//This implementation is no longer recommended for use.
</span>    <span class="cm">/*
    Some implementation
    */</span>
<span class="p">}</span>
<span class="cp">#else
</span><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">//A better foo implementation
</span>    <span class="cm">/*
    Some implementation
    */</span>
<span class="p">}</span>
<span class="cp">#endif
</span>
</code></pre>
</div>
<h6 id="fig121">Fig(1.21)</h6>

<p>The above snippet includes the old version of the function <code class="highlighter-rouge">foo()</code> if <code class="highlighter-rouge">USE_OLD_FOO</code> is defined, else by default the new version would be used. One may need to use old versions of codes for legacy support (say). But when using the old version, the developer would like to warn the user about it. In such cases, you can use the <code class="highlighter-rouge">#warning</code> directive. The <code class="highlighter-rouge">#errror</code> is similar, but throws an error</p>

<hr />
<h2 id="swapping-two-variables">Swapping two variables</h2>

<p><strong>Feature/Trick 6</strong> : This is more a programming trick than a trick in C. To swap two variables without using additional space or arithmetic operators, you can simply use the xor operator; like so -</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">^</span> <span class="n">b</span><span class="p">;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">^</span> <span class="n">b</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">^</span> <span class="n">b</span><span class="p">;</span>
</code></pre>
</div>
<h6 id="fig21">Fig(2.1)</h6>

<hr />
<h2 id="pointers-in-c">Pointers in C</h2>

<h3 id="arrays-and-pointers-not-entirely-the-same">Arrays and Pointers not entirely the same!</h3>

<p><strong>Feature/Trick 7</strong> : One of the heavily misunderstood concepts of C is that pointers and arrays are the same. They are not. Pointers are merely variables holding the address of some location where as an array is conceptualized as a sequence of memory locations of a type. At compile time, an array is an array. Only during runtime, an array degenerates to a pointer. To prove this fact, let me show you an example -</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span> <span class="p">};</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
</code></pre>
</div>
<h6 id="fig31">Fig(3.1)</h6>

<p>And the output is (assuming size of int is 4 bytes and address size is 8 bytes) -</p>

<div class="highlighter-rouge"><pre class="highlight"><code>40
8
</code></pre>
</div>
<h6 id="fig32">Fig(3.2)</h6>

<p>See what happens? At compile time, the compiler has information regarding the array. It drops all the information in the end and so at runtime, an array acts like a constant pointer.</p>

<h3 id="vindex-and-indexv-are-the-same"><code class="highlighter-rouge">v[index] and index[v]</code> are the same</h3>

<p><strong>Feature/Trick 8</strong> : Yes arrays and pointers are not the same, but are interpreted in the same way; by dereferencing them to get the value. The indexing operation <code class="highlighter-rouge">v[index]</code> where <code class="highlighter-rouge">v</code> is some array and <code class="highlighter-rouge">index</code> is some index is internally converted to <code class="highlighter-rouge">*(v + index)</code>. The funny thing now is that if you use this as <code class="highlighter-rouge">index[v]</code>, its converted to <code class="highlighter-rouge">*(index + v)</code> and both mean the same!</p>

<hr />
<h2 id="standard-io">Standard I/O</h2>

<p><strong>Feature/Trick 9</strong> :You are no doubt familiar with <code class="highlighter-rouge">scanf</code> and <code class="highlighter-rouge">printf</code> functions. You also be familiar with <code class="highlighter-rouge">fscanf</code> and <code class="highlighter-rouge">fprintf</code> if you have worked on file handling.
For example -</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">FILE</span> <span class="o">*</span><span class="n">fptr</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"some_file.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">first_name</span><span class="p">;</span> <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>

<span class="n">fscanf</span><span class="p">(</span><span class="n">fptr</span><span class="p">,</span> <span class="s">"%s %d"</span><span class="p">,</span> <span class="n">first_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">age</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Name: %s</span><span class="se">\n</span><span class="s">Age: %d</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span> <span class="n">first_name</span><span class="p">,</span> <span class="n">age</span><span class="p">);</span>

<span class="n">fclose</span><span class="p">(</span><span class="n">fptr</span><span class="p">);</span>
</code></pre>
</div>
<h6 id="fig41">Fig(4.1)</h6>

<p>The above snippet demonstrates reading from a file using <code class="highlighter-rouge">fscanf</code>.<br />
How about this? You have a string containing two integers and you’d like to read from that. Its not a file name, its a character array. C provides reading and writing to character arrays (or C strings) with the use of <code class="highlighter-rouge">sscanf</code> and <code class="highlighter-rouge">sprintf</code>.<br />
Let me demonstrate this -</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="s">"10 20"</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>

<span class="n">sscanf</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">"%d %d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
<span class="n">sprintf</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">"%d %d"</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">*</span><span class="n">b</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
</code></pre>
</div>
<h6 id="fig42">Fig(4.2)</h6>

<p>In the above snippet, a string contains two numbers 10 and 20 (as characters of the string). Using sscanf you can read these to variables and also write back to the C string!</p>

<p><strong>Feature/Trick 10</strong> : <code class="highlighter-rouge">scanf</code> is probably one of the most magical function in C. To know more about the tricks in <code class="highlighter-rouge">scanf</code>, visit <a href="http://qr.ae/IHQTN">my answer in quora</a> about the same.</p>

<p><strong>Feature/Trick 11</strong> : One of the many problems with C strings is reading them; C strings can easily overflow if a string longer than size of the character array is entered. <code class="highlighter-rouge">scanf</code> is useless and so is <code class="highlighter-rouge">gets</code>. The best function to use when reading strings is <code class="highlighter-rouge">fgets</code>. <code class="highlighter-rouge">fgets</code> takes the string, the length to be read and the file stream where the string is to be read from as arguments. If you want to read from the console, you can use <code class="highlighter-rouge">stdin</code> as your input file stream. The function call would then go like this -</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">n</span><span class="p">;</span> <span class="c1">//some length; maybe known later.
</span><span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="n">n</span><span class="p">];</span> <span class="c1">//works from c99
</span>
<span class="n">fgets</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span> <span class="c1">//reads max n characters to 'str' from stdin.
</span></code></pre>
</div>
<h6 id="fig43">Fig(4.3)</h6>

<p>You can also use the new <code class="highlighter-rouge">gets_s</code> function; but <code class="highlighter-rouge">fgets</code> is pretty much the standard convention.</p>

<hr />
<h2 id="c99-c11-and-misc">C99, C11 and misc</h2>

<p>You’ve been using the old fashioned way of initializing C structures right? Like so -</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">foo</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">foo</span> <span class="n">f</span> <span class="o">=</span> <span class="p">{</span><span class="mi">100</span><span class="p">,</span> <span class="mi">123</span><span class="p">};</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">f</span><span class="p">.</span><span class="n">a</span><span class="p">,</span> <span class="n">f</span><span class="p">.</span><span class="n">b</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<h6 id="fig51">Fig(5.1)</h6>

<p><strong>Feature/Trick 12</strong> : C99 provides a new way of doing the same with more ease. Like so -</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">foo</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">foo</span> <span class="n">f</span> <span class="o">=</span> <span class="p">{.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">123</span><span class="p">,</span> <span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">100</span><span class="p">};</span> <span class="c1">// C99 style
</span>    <span class="n">printf</span><span class="p">(</span><span class="s">"%d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">f</span><span class="p">.</span><span class="n">a</span><span class="p">,</span> <span class="n">f</span><span class="p">.</span><span class="n">b</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<h6 id="fig52">Fig(5.2)</h6>

<p><strong>Feature/Trick 13</strong> : C99 also provides a mechanism to initialize only certain indices of an array.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">};</span> <span class="c1">//initializes a[0] and a[50] to 1 and the rest 0
</span><span class="n">printf</span><span class="p">(</span><span class="s">"%d %d %d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">50</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">51</span><span class="p">]);</span>
</code></pre>
</div>
<h6 id="fig53">Fig(5.3)</h6>

<p><strong>Feature/Trick 14</strong> : Did you know about the <code class="highlighter-rouge">atexit</code> function? This function can be used to register functions that are to be called when the program finishes its execution! For example -</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Goodbye Foo!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bar</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Goodbye Bar!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">atexit</span><span class="p">(</span><span class="n">bar</span><span class="p">);</span>
    <span class="n">atexit</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
</div>
<h6 id="fig54">Fig(5.4)</h6>

<p>Notice that <code class="highlighter-rouge">foo</code> and <code class="highlighter-rouge">bar</code> functions haven’t been called but are registered to be called when the program exits. Such functions should not return anything nor accept any arguments. You can register upto 32 such functions. They’ll be called in the LIFO order.</p>

<p><strong>Feature/Trick 15</strong> : I found this somewhere in stackoverflow. It seems that a game the developer had to initialize a huge two dimensional float array with lots of values. And he employed this to do so -</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">double</span> <span class="n">array</span><span class="p">[</span><span class="n">SIZE</span><span class="p">][</span><span class="n">SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="cp">#include "float_values.txt"
</span><span class="p">}</span>
</code></pre>
</div>
<h6 id="fig56">Fig(5.6)</h6>

<p>The file <em>float_values.txt</em> contains all the values to be initialized in the array. This way, the values are not inlined in the file containing the code. The preprocessor will have included that file. Nice idea!</p>

<p><strong>Feature/Trick 16</strong> : C11 has introduced something great! Heard of templates in C++ where you could write type independent code? Well, that’s possible in a slightly different way in C11 now! Want to see how? Scroll down a little.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
</span>
<span class="kt">void</span> <span class="nf">printchar</span><span class="p">(</span><span class="kt">char</span> <span class="n">X</span><span class="p">)</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">"char: %c</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">X</span><span class="p">);</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">printint</span><span class="p">(</span><span class="kt">int</span> <span class="n">X</span><span class="p">)</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">"int: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">X</span><span class="p">);</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">printfloat</span><span class="p">(</span><span class="kt">float</span> <span class="n">X</span><span class="p">)</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">"float: %f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">X</span><span class="p">);</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">printdouble</span><span class="p">(</span><span class="kt">double</span> <span class="n">X</span><span class="p">)</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">"double: %lf</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">X</span><span class="p">);</span> <span class="p">}</span>
<span class="cp">#define print(X) _Generic((X), \
                               char: printchar, \
                               int: printint, \
                               float: printfloat, \
                               double: printdouble)(X)
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">print</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">print</span> <span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">print</span> <span class="p">((</span><span class="kt">char</span><span class="p">)</span><span class="sc">'a'</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
</div>
<h6 id="fig57">Fig(5.7)</h6>

<p>The above program illustrates a generic <code class="highlighter-rouge">print</code> function which adapts to the type of the argument sent! How is this achieved? C11 introduced the <code class="highlighter-rouge">_Generic</code> keyword. This maps the type and the corresponding function that should be called for the type. You can abstract this to a function-like MACRO. In the above program, a function-like macro <code class="highlighter-rouge">print(X)</code> is defined to expand to the <code class="highlighter-rouge">_Generic</code> keyword construct. This takes in as its first argument <code class="highlighter-rouge">_Generic((X), ...</code>as the parameter and the rest map the type to the function that needs to be called <code class="highlighter-rouge">_Generic((X), char: printchar, int: printint, ...</code>; in the end this construct is invoked like a function by passing the value <code class="highlighter-rouge">...double: printdouble)(X)</code>. The abstract function-like MACRO can be used to call this type-generic function and that’s cool!</p>

<p>That’s it folks! Hope you enjoyed reading this!</p>

  </div>
</div>

    <br/>
    
      <div id="disqus_thread"></div>
<script>
var disqus_config = function () {
this.page.url = "https://sathyam.me/oldblog/cool-c-programming/";  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = "/oldblog/cool-c-programming/"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://sathyam.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

    
  </div>
  <br/>
  <hr/>
  <div class="footer wrapper">
    <div class="container">
  <p class="text-center grey">Find me on</p>
  <ul>
    
      <li>
          <a class="text-dark" href="https://twitter.com/sathyamvellal" target="_blank"><i class="fab fa-twitter"></i></a>
      </li>
    
      <li>
          <a class="text-dark" href="https://github.com/sathyamvellal" target="_blank"><i class="fab fa-github"></i></a>
      </li>
    
      <li>
          <a class="text-dark" href="https://linkedin.com/in/sathyamvellal" target="_blank"><i class="fab fa-linkedin-in"></i></a>
      </li>
    
      <li>
          <a class="text-dark" href="https://www.instagram.com/sathyamvellal/" target="_blank"><i class="fab fa-instagram"></i></a>
      </li>
    
      <li>
          <a class="text-dark" href="https://www.youtube.com/c/SathyamVellal" target="_blank"><i class="fab fa-youtube"></i></a>
      </li>
    
      <li>
          <a class="text-dark" href="https://www.mixcloud.com/sathyamvellal" target="_blank"><i class="fab fa-mixcloud"></i></a>
      </li>
    
      <li>
          <a class="text-dark" href="https://letterboxd.com/sathyamvellal/" target="_blank"><i class="fas fa-film"></i></a>
      </li>
    
      <li>
          <a class="text-dark" href="https://pinboard.in/u:sathyamvellal" target="_blank"><i class="fas fa-thumbtack"></i></a>
      </li>
    
      <li>
          <a class="text-dark" href="https://strava.com/athletes/sathyamvellal" target="_blank"><i class="fab fa-strava"></i></a>
      </li>
    
  </ul>
</div>

  </div>
  <script type="text/javascript">
// $(".span-tooltip").tooltip();
$(".span-popover").popover();
</script>

</body>
</html>
